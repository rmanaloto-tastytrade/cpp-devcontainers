**Findings**
- Artifact/tag map is fragmented and unused: each build uploads its own `TAG_MAP_FILE` but the publish job never downloads/validates it and re-derives tags from the permutation name. That leaves no consolidated ref→tag map artifact and no guard that all permutations produced tags/digests before pushing. Recommend a single collected tag map (fail if any perm missing) and have publish consume it.
- Publish job lacks push gating beyond SBOM/Trivy per-tar: it assumes artifacts exist and are complete, with no count check vs the matrix and no concurrency group on publish, so a rerun could push partial/duplicate tags. Add an expected permutation list + artifact presence check and reuse the same concurrency group for publish.
- Runner hygiene/retention: build/publish leave `/tmp/devcontainer-*.tar` and caches on the runner; cleanup only prunes docker images/builders. No GHCR retention/rollback path is documented. Add explicit `/tmp` cleanup, cache pruning per job, and document/automate GHCR rollback/retention.
- Security deferrals: no signing/attestation/provenance on pushed images; Trivy/hadolint are version-pinned but not by digest; secrets/runner-handling guidance isn’t documented. Plan for cosign/attestations, digest-pinning scanners, and a short secrets/runner doc (who owns GHCR creds, runner hardening).
- Cache poisoning risk: buildx cache uses shared `gha` scope `${target}-${GITHUB_REF_NAME}` and is reused across PR/main. Even with no-cache validation, a malicious branch could seed cache for main. Salt cache scopes by event (main vs PR), or disable cache on PR builds; optionally enable `--pull --no-cache` for publish/builder or require base-digest validation from the tag map.