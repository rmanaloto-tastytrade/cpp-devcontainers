#!/usr/bin/env bash
set -euo pipefail

CURRENT_USER="${DEVCONTAINER_USER:-$(id -un)}"
CURRENT_GROUP="$(id -gn "$CURRENT_USER" 2>/dev/null || id -gn)"
WORKSPACE_DIR="${WORKSPACE_FOLDER:-/home/${CURRENT_USER}/workspace}"
CLANG_VARIANT="${CLANG_VARIANT:-21}"
GCC_VERSION="${GCC_VERSION:-14}"
SUDO=""
if command -v sudo >/dev/null 2>&1 && sudo -n true >/dev/null 2>&1; then
  SUDO="sudo -n"
fi
CACHE_ROOT="/cppdev-cache"
CCACHE_DIR="${CCACHE_DIR:-${CACHE_ROOT}/ccache}"
SCCACHE_DIR="${SCCACHE_DIR:-${CACHE_ROOT}/sccache}"
VCPKG_DOWNLOADS="${VCPKG_DOWNLOADS:-${CACHE_ROOT}/vcpkg-downloads}"
VCPKG_BINARY_CACHE="${VCPKG_DEFAULT_BINARY_CACHE:-${CACHE_ROOT}/vcpkg-archives}"
PERSISTENT_TMP="${TMPDIR:-${CACHE_ROOT}/tmp}"
VCPKG_REPO="${VCPKG_REPO:-${CACHE_ROOT}/vcpkg-repo}"
VCPKG_ROOT="${VCPKG_ROOT:-/opt/vcpkg}"
VCPKG_REF="${VCPKG_REF:-}"
PATH_SNIPPET_FILE="${HOME}/.config/cppdev/path.sh"

chown_safe() {
  if [ -n "${SUDO}" ]; then
    ${SUDO} chown "$@"
  else
    chown "$@"
  fi
}

if [ -n "${SUDO}" ]; then
  ${SUDO} mkdir -p /opt/vcpkg
  ${SUDO} chown -R "${CURRENT_USER}:${CURRENT_GROUP}" /opt/vcpkg "${WORKSPACE_DIR}" || true
fi
if [ -d /opt/vcpkg ] && [ ! -L /opt/vcpkg ]; then
  echo "[post_create] Replacing /opt/vcpkg directory with symlink to ${VCPKG_REPO}..."
  if [ -n "${SUDO}" ]; then
    ${SUDO} rm -rf /opt/vcpkg || rm -rf /opt/vcpkg
  else
    rm -rf /opt/vcpkg
  fi
fi

echo "[post_create] Preparing persistent cache root at ${CACHE_ROOT}..."
mkdir -p "${CACHE_ROOT}"/{ccache,sccache,vcpkg-downloads,vcpkg-archives,tmp}
chown_safe -R "${CURRENT_USER}:${CURRENT_GROUP}" "${CACHE_ROOT}"

# Prepare vcpkg caches on the persistent volume (env variables point to these)
mkdir -p "${VCPKG_DOWNLOADS}" "${VCPKG_BINARY_CACHE}"
chown_safe -R "${CURRENT_USER}:${CURRENT_GROUP}" "${VCPKG_DOWNLOADS}" "${VCPKG_BINARY_CACHE}"

# Ensure vcpkg checkout lives on the persistent volume
mkdir -p "${VCPKG_REPO}"
if [ ! -d "${VCPKG_REPO}/.git" ]; then
  echo "[post_create] Cloning vcpkg into ${VCPKG_REPO}..."
  if [ -n "${VCPKG_REF}" ]; then
    git clone --depth=1 --branch "${VCPKG_REF}" https://github.com/microsoft/vcpkg.git "${VCPKG_REPO}"
  else
    git clone --depth=1 https://github.com/microsoft/vcpkg.git "${VCPKG_REPO}"
  fi
elif [ -n "${VCPKG_REF}" ]; then
  echo "[post_create] Checking out pinned vcpkg ref ${VCPKG_REF}..."
  git -C "${VCPKG_REPO}" fetch --depth=1 origin "${VCPKG_REF}" || true
  git -C "${VCPKG_REPO}" checkout "${VCPKG_REF}" || true
else
  echo "[post_create] Leaving existing vcpkg checkout as-is (no VCPKG_REF set)."
fi
if [ ! -x "${VCPKG_REPO}/vcpkg" ]; then
  echo "[post_create] Bootstrapping vcpkg..."
  (cd "${VCPKG_REPO}" && ./bootstrap-vcpkg.sh -disableMetrics)
fi
link_with_sudo() {
  local target="$1"; local link="$2"
  if [ -n "${SUDO}" ]; then
    ${SUDO} ln -snf "$target" "$link" || ln -snf "$target" "$link"
  else
    ln -snf "$target" "$link"
  fi
}
# Ensure /opt/vcpkg points at the persistent repo and downloads points at the cache
link_with_sudo "${VCPKG_REPO}" /opt/vcpkg
link_with_sudo "${VCPKG_DOWNLOADS}" /opt/vcpkg/downloads
chown_safe -R "${CURRENT_USER}:${CURRENT_GROUP}" "${VCPKG_REPO}" /opt/vcpkg
if [ -n "${SUDO}" ]; then
  ${SUDO} ln -snf /opt/vcpkg/vcpkg /usr/local/bin/vcpkg || true
else
  ln -snf /opt/vcpkg/vcpkg /usr/local/bin/vcpkg || true
fi

# Compute and persist a permutation-aware PATH
compute_path_prefix() {
  local cv="$CLANG_VARIANT"
  local gv="$GCC_VERSION"
  local parts=("/usr/local/bin")
  if [ "$cv" = "p2996" ]; then
    parts+=("/opt/clang-p2996/bin")
  else
    parts+=("/usr/lib/llvm-${cv}/bin")
  fi
  if [ "$gv" = "15" ]; then
    parts+=("/opt/gcc-15/bin")
  fi
  parts+=("${VCPKG_ROOT}" "/opt/mrdocs/bin")
  parts+=("${HOME}/.local/bin")
  (IFS=:; echo "${parts[*]}")
}
PATH_PREFIX="$(compute_path_prefix)"
export PATH="${PATH_PREFIX}:${PATH}"
export CC="clang-${CLANG_VARIANT}"
export CXX="clang++-${CLANG_VARIANT}"
mkdir -p "$(dirname "${PATH_SNIPPET_FILE}")"
cat > "${PATH_SNIPPET_FILE}" <<EOF
# Generated by post_create.sh
export PATH="${PATH_PREFIX}:\${PATH}"
export CC="clang-${CLANG_VARIANT}"
export CXX="clang++-${CLANG_VARIANT}"
EOF
for shell_rc in "${HOME}/.bashrc" "${HOME}/.zshrc"; do
  if [ -f "$shell_rc" ] && ! grep -q 'cppdev/path.sh' "$shell_rc"; then
    echo "source ${PATH_SNIPPET_FILE}" >> "$shell_rc"
  elif [ ! -f "$shell_rc" ]; then
    echo "source ${PATH_SNIPPET_FILE}" > "$shell_rc"
  fi
done

# Ensure ccache/sccache dirs are owned and writable
mkdir -p "${CCACHE_DIR}" "${SCCACHE_DIR}"
chown_safe -R "${CURRENT_USER}:${CURRENT_GROUP}" "${CCACHE_DIR}" "${SCCACHE_DIR}"

# Ensure aws CLI is on PATH if installed in the default location
if ! command -v aws >/dev/null 2>&1; then
  if [ -x /opt/aws-cli/v2/current/bin/aws ]; then
    if [ -n "${SUDO}" ]; then
      ${SUDO} ln -snf /opt/aws-cli/v2/current/bin/aws /usr/local/bin/aws || true
    else
      ln -snf /opt/aws-cli/v2/current/bin/aws /usr/local/bin/aws || true
    fi
  else
    echo "[post_create] aws not found; installing via pip..."
    if [ -n "${SUDO}" ]; then
      ${SUDO} pip3 install -q awscli || true
    else
      pip3 install -q --user awscli || true
    fi
  fi
fi

# Make /tmp persistent via symlink into the cache volume if empty
if [ ! -L /tmp ] && [ -z "$(ls -A /tmp)" ]; then
  rm -rf /tmp
  ln -snf "${PERSISTENT_TMP}" /tmp
fi

if ! command -v "clang++-${CLANG_VARIANT}" >/dev/null 2>&1; then
  echo "[post_create] ERROR: clang++-${CLANG_VARIANT} not found in PATH" >&2
  exit 1
fi

SSH_SOURCE="${WORKSPACE_DIR}/.devcontainer/ssh"
SSH_TARGET="$HOME/.ssh"

if compgen -G "$SSH_SOURCE/"'*.pub' > /dev/null; then
  mkdir -p "$SSH_TARGET"
  chmod 700 "$SSH_TARGET"
  touch "$SSH_TARGET/known_hosts"
  chmod 600 "$SSH_TARGET/known_hosts"
  if ls "$SSH_TARGET"/id_* 2>/dev/null | grep -v '\.pub$' > /dev/null; then
    echo "[post_create] WARNING: Private keys detected in $SSH_TARGET - will not modify them"
  fi
  if [[ -f "$SSH_TARGET/authorized_keys" ]]; then
    cp "$SSH_TARGET/authorized_keys" "$SSH_TARGET/authorized_keys.backup.$(date +%Y%m%d-%H%M%S)"
    echo "[post_create] Backed up existing authorized_keys"
  fi
  cat "$SSH_SOURCE/"*.pub > "$SSH_TARGET/authorized_keys"
  chmod 600 "$SSH_TARGET/authorized_keys"
  echo "[post_create] Installed authorized_keys from $SSH_SOURCE"
else
  echo "[post_create] WARNING: No public keys found under $SSH_SOURCE"
fi

# Sanitize macOS SSH config (UseKeychain is unsupported on Linux)
SSH_CONFIG_FILE="$SSH_TARGET/config"
if [[ -f "$SSH_CONFIG_FILE" ]] && grep -q "UseKeychain" "$SSH_CONFIG_FILE"; then
  cp "$SSH_CONFIG_FILE" "$SSH_TARGET/config.macbak"
  grep -v "UseKeychain" "$SSH_TARGET/config.macbak" > "$SSH_CONFIG_FILE"
  chmod 600 "$SSH_CONFIG_FILE"
  echo "[post_create] Filtered UseKeychain from ~/.ssh/config (backup at ~/.ssh/config.macbak)."
fi

# Force GitHub SSH over 443 inside the container (port 22 is often blocked on remote hosts).
# See: https://docs.github.com/en/authentication/troubleshooting-ssh/using-ssh-over-the-https-port
{
  echo ""
  echo "# Added by post_create.sh for cpp-devcontainer: use GitHub SSH over 443"
  echo "Host github.com"
  echo "  Hostname ssh.github.com"
  echo "  Port 443"
  echo "  User git"
  echo "  CanonicalizeHostname no  # avoid company DNS suffixes (e.g., github.com.tastyworks.com)"
  echo "  StrictHostKeyChecking yes"
  echo "  UserKnownHostsFile ~/.ssh/known_hosts"
} >> "$SSH_CONFIG_FILE"
chmod 600 "$SSH_CONFIG_FILE"

# Preseed GitHub host keys for port 443 to avoid StrictHostKeyChecking prompts
if command -v ssh-keyscan >/dev/null 2>&1; then
  ssh-keyscan -p 443 ssh.github.com 2>/dev/null | sort -u >> "$SSH_TARGET/known_hosts" || true
fi

# CMake configuration is project-specific; skip auto-configure for generic devcontainer
